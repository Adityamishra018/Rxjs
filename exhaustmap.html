<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<style>
    button{
        margin: 20px;
    }
</style>
<body>
    <h2>Open your console on the side and work on the buttons ðŸ”¥</h2>
    
    <button onclick="emitNext()">Click me to emit next val!</button>

    <button onclick="complete()">Click me to complete observable</button>

    <script src="https://unpkg.com/rxjs@^7/dist/bundles/rxjs.umd.min.js"></script>
    <script>
        obs1$ = new rxjs.Subject()

        buffer = ['a','b','c','d','e']
        i = 0;
        function emitNext(){
            if(i < buffer.length)
                obs1$.next(buffer[i++])
            else
                complete()
        }

        function complete(){
            obs1$.complete()
        }

        obs1$.pipe(
            /*
                exhaustMap operator in RxJS maps each value from a source observable to an "inner" observable, but it ignores all new values from the source while that inner observable is still active. It waits for the current inner observable to complete before accepting and processing the next value from the source. 

                This behavior is perfect for scenarios where you want to prevent multiple requests or actions from happening at the same time, such as preventing double clicks on a submit button

                Compare this with MergeMap and ConcatMap.
            */
            rxjs.exhaustMap(c =>{
                return rxjs.interval(1000).pipe(
                    rxjs.map(i => `${c} : ${i}`),
                    rxjs.take(10)
            )})
        ).subscribe(console.log)
    </script>
</body>
</html>